{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, Inject } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\n\nconst sumValues = (source, keys) => {\n  let result = 0;\n  keys.forEach(key => {\n    const property = source[key];\n    const value = parseInt(property, 10) || 0;\n    result += value;\n  });\n  return result;\n};\n\nconst getScale = (imageHeight, imageWidth, maxHeight, maxWidth) => {\n  const widthScale = maxWidth / imageWidth;\n  const heightScale = maxHeight / imageHeight;\n  const widthScaleIsOkay = imageHeight * widthScale <= maxHeight;\n  return widthScaleIsOkay ? widthScale : heightScale;\n};\n\nconst unzoomImage = image => {\n  var _a;\n\n  image.style.transform = 'scale(1)';\n  (_a = image.parentElement) === null || _a === void 0 ? void 0 : _a.classList.remove('image-zoom-wrapper-zoomed');\n  image.addEventListener('transitionend', () => {\n    image.classList.remove('image-zoom-zoomed');\n  }, {\n    once: true\n  });\n};\n\nconst css = `\n:root {\n    overflow-x: hidden;\n}\n.image-zoom-wrapper::after {\n    opacity: 0;\n    transition: opacity 150ms cubic-bezier(.25, .1, .25 ,1);\n    display: block;\n    content: '';\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background-color: white;\n    z-index: 99998;\n    pointer-events: none;\n}\n.image-zoom-wrapper.image-zoom-wrapper-zoomed::after {\n    opacity: 1;\n    cursor: zoom-out;\n    pointer-events: all;\n}\n.image-zoom {\n    transition: transform 300ms cubic-bezier(.25, .1, .25 ,1);\n    cursor: zoom-in;\n}\n.image-zoom-zoomed {\n    position: relative;\n    z-index: 99999;\n    cursor: zoom-out !important;\n}\n`;\n\nfunction debounce(func, waitMilliseconds = 50, options = {}) {\n  var _a, _b;\n\n  let timeoutId;\n  const isImmediate = (_a = options.isImmediate) !== null && _a !== void 0 ? _a : false;\n  const callback = (_b = options.callback) !== null && _b !== void 0 ? _b : false;\n  const maxWait = options.maxWait;\n  let lastInvokeTime = Date.now();\n  let promises = [];\n\n  function nextInvokeTimeout() {\n    if (maxWait !== undefined) {\n      const timeSinceLastInvocation = Date.now() - lastInvokeTime;\n\n      if (timeSinceLastInvocation + waitMilliseconds >= maxWait) {\n        return maxWait - timeSinceLastInvocation;\n      }\n    }\n\n    return waitMilliseconds;\n  }\n\n  const debouncedFunction = function (...args) {\n    const context = this;\n    return new Promise((resolve, reject) => {\n      const invokeFunction = function () {\n        timeoutId = undefined;\n        lastInvokeTime = Date.now();\n\n        if (!isImmediate) {\n          const result = func.apply(context, args);\n          callback && callback(result);\n          promises.forEach(({\n            resolve\n          }) => resolve(result));\n          promises = [];\n        }\n      };\n\n      const shouldCallNow = isImmediate && timeoutId === undefined;\n\n      if (timeoutId !== undefined) {\n        clearTimeout(timeoutId);\n      }\n\n      timeoutId = setTimeout(invokeFunction, nextInvokeTimeout());\n\n      if (shouldCallNow) {\n        const result = func.apply(context, args);\n        callback && callback(result);\n        return resolve(result);\n      }\n\n      promises.push({\n        resolve,\n        reject\n      });\n    });\n  };\n\n  debouncedFunction.cancel = function (reason) {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n    }\n\n    promises.forEach(({\n      reject\n    }) => reject(reason));\n    promises = [];\n  };\n\n  return debouncedFunction;\n}\n\nlet NgZoom = /*#__PURE__*/(() => {\n  class NgZoom {\n    constructor(document) {\n      this.document = document;\n      this.defaultConfig = {\n        padding: 20,\n        exceed: false\n      };\n      this.zoomed = null;\n      this.handleClick = debounce(image => {\n        if (this.zoomed) {\n          unzoomImage(this.zoomed);\n          this.zoomed = null;\n          return;\n        }\n\n        if (image) {\n          this.zoomImage(image, this.defaultConfig);\n          this.zoomed = image;\n        }\n      }, 500, {\n        isImmediate: true\n      });\n\n      this.handleUnzoomingInteraction = () => {\n        if (!this.zoomed) return;\n        unzoomImage(this.zoomed);\n        this.zoomed = null;\n      };\n\n      this.handleKeydown = e => {\n        if (e.code != 'Escape') return;\n        e.preventDefault();\n\n        if (this.zoomed) {\n          unzoomImage(this.zoomed);\n          this.zoomed = null;\n        }\n      };\n\n      this.injectStyles = () => {\n        const styles = this.document.createElement('style');\n        styles.innerHTML = css;\n        this.document.head.appendChild(styles);\n      };\n\n      this.zoomImage = (image, config) => {\n        var _a, _b;\n\n        const imageRect = image.getBoundingClientRect();\n        const imageStyle = this.window.getComputedStyle(image);\n        const imageWidth = imageRect.width - sumValues(imageStyle, ['borderLeftWidth', 'borderRightWidth', 'paddingLeft', 'paddingRight']);\n        const imageHeight = imageRect.height - sumValues(imageStyle, ['borderTopWidth', 'borderBottomWidth', 'paddingTop', 'paddingBottom']);\n        const vw = this.window.innerWidth;\n        const vh = this.window.innerHeight;\n        const shouldExceed = config.exceed || ((_a = image.dataset) === null || _a === void 0 ? void 0 : _a['imageZoomExceed']) == 'true';\n        let scale = getScale(imageHeight, imageWidth, vh, vw);\n\n        if (!shouldExceed) {\n          const limitedScale = getScale(imageHeight, imageWidth, image.naturalHeight, image.naturalWidth);\n          scale = Math.min(scale, limitedScale);\n        }\n\n        const isPaddingNeeded = config.padding > Math.min(vh - imageHeight * scale, vw - imageWidth * scale) / 2;\n\n        if (isPaddingNeeded) {\n          let scaleWithPaddingBeforeExceed = getScale(imageHeight + config.padding, imageWidth + config.padding, vh, vw);\n\n          if (!shouldExceed) {\n            const limitedScale = getScale(imageHeight, imageWidth, image.naturalHeight - config.padding, image.naturalWidth - config.padding);\n            scaleWithPaddingBeforeExceed = Math.min(scaleWithPaddingBeforeExceed, limitedScale);\n          }\n\n          scale = scaleWithPaddingBeforeExceed;\n        }\n\n        const doc = this.document.documentElement;\n        const scrollLeft = (this.window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);\n        const scrollTop = (this.window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\n        const imageCenterX = scrollLeft + imageRect.left + imageRect.width / 2;\n        const imageCenterY = scrollTop + imageRect.top + imageRect.height / 2;\n        const screenCenterX = scrollLeft + vw / 2;\n        const screenCenterY = scrollTop + vh / 2;\n        const translateX = (screenCenterX - imageCenterX) / scale;\n        const translateY = (screenCenterY - imageCenterY) / scale;\n        image.classList.add('image-zoom-zoomed');\n        (_b = image.parentElement) === null || _b === void 0 ? void 0 : _b.classList.add('image-zoom-wrapper-zoomed');\n        image.style.transform = `scale(${scale}) translate(${translateX}px, ${translateY}px)`;\n      };\n\n      this.processImage = image => {\n        var _a; // create an image wrapper element\n\n\n        const wrapper = this.document.createElement('div'); // let wrapper mimick pearl display property to not break anything\n\n        wrapper.classList.add('image-zoom-wrapper');\n        wrapper.style.display = this.window.getComputedStyle(image).display;\n        (_a = image.parentElement) === null || _a === void 0 ? void 0 : _a.insertBefore(wrapper, image);\n        wrapper.appendChild(image);\n        image.classList.add('image-zoom');\n        image.style.transform = 'scale(1)';\n      };\n\n      this.window = this.document.defaultView;\n      this.injectStyles();\n      this.document.body.addEventListener('click', () => {\n        this.handleClick(null);\n      });\n      this.document.addEventListener('keydown', this.handleKeydown);\n      this.window.addEventListener('scroll', this.handleUnzoomingInteraction);\n      this.window.addEventListener('resize', this.handleUnzoomingInteraction);\n    }\n\n    listen(imageRef) {\n      const image = imageRef.nativeElement;\n      this.processImage(image);\n      image.addEventListener('click', () => {\n        this.handleClick(image);\n      });\n    }\n\n  }\n\n  NgZoom.ɵfac = function NgZoom_Factory(t) {\n    return new (t || NgZoom)(i0.ɵɵinject(DOCUMENT));\n  };\n\n  NgZoom.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NgZoom,\n    factory: NgZoom.ɵfac,\n    providedIn: 'root'\n  });\n  return NgZoom;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Public API Surface of ng-zoom\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NgZoom }; //# sourceMappingURL=ng-zoom.mjs.map","map":null,"metadata":{},"sourceType":"module"}